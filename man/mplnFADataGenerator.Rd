% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mplnFAsimulate.R
\name{mplnFADataGenerator}
\alias{mplnFADataGenerator}
\title{Generating Data Using Mixture of MPLN Factor Analyzers}
\usage{
mplnFADataGenerator(
  numDatasets = 10,
  nObservations = 1000,
  dimensionality = 10,
  mixingProportions = c(0.32, 0.68),
  trueClusters = 2,
  pfactors = 3,
  modelName = "CCC",
  mu = list(c(6, 3, 3, 6, 3, 6, 3, 3, 6, 3), c(5, 3, 5, 3, 5, 5, 3, 5, 3, 5)),
  Lambda = list(matrix(runif(3 * 10, -1, 1), nrow = 10), matrix(runif(3 * 10, -1, 1),
    nrow = 10)),
  Psi = list(diag(10) * runif(1), diag(10) * runif(1))
)
}
\arguments{
\item{numDatasets}{A positive integer indicating the number
of datasets to be generated. Default value is 10.}

\item{nObservations}{A positive integer indicating the number
of observations for the dataset. Or the sample size. Default
value is 1000.}

\item{dimensionality}{A positive integer indicating the
dimensionality for the dataset. Default value is 10.}

\item{trueClusters}{A positive integer indicating the number
of total components or clusters. Default value is 2.}

\item{pfactors}{A positive integer indicating the number
of total latent factors. Default value is 3.}

\item{mu}{A list of length equal to the value provided to 'trueClusters' argument
and each element should have length equal to the value provided to
'dimensionality' argument. See example or default value.}

\item{Lambda}{A list of length 'trueClusters' with each list element having
a matrix with rows equal to value provided to 'dimensionality' argument
and columns equal to value provided to 'pfactors' argument. The values
should be provided as per the model used in modelNames argument. See example
or default values.}

\item{Psi}{Psi should be a list of length 'trueClusters' with each list
element having a matrix with rows equal to value provided to
'dimensionality' argument and columns equal to value provided to
'dimensionality' argument. The values should be provided as per the
model used in modelNames argument. See example or default values.}

\item{modelNames}{A character string indicating the model name to generate
covariance matrix, Sigma. Since the largest contribution of free parameters
is through the covariance matrices, it is the focus for introduction
of parsimony. The constraints can be imposed on Lambda (loading matrix)
and Psi (error variance and isotropic) which are used to generate Sigma.
The 'C' stands for constrained and 'U' stands for unconstrained. The order
goes as loading matrix (Lambda), error variance (Psi) and isotropic (Psi),
respectively. Example, if the loading matrix (Lambda), error variance (Psi)
and isotropic are all constrained, then select 'CCC'. Options are one of "CCC",
"UUU", or "UCC".}
}
\value{
Returns an S3 object of class mplnFADataGenerator with results that
equal the length of numDatasets argument. For each dataset generated, the
following values are provided.
\itemize{
\item input - User provided parameters and values used to generate the dataset.
\item dataset - Simulated dataset of counts that has dimensions nObservations x
dimensionality.
\item Xmatrix - The matrix of X values that has dimensions nObservations x
dimensionality.
\item zmatrix - The matrix of membership indicator variables indicating which
cluster/component each observation belongs to.
\item Umatrix - The matrix containing latent factors for each observation. This
has dimensions nObservations x pfactors.
}
}
\description{
This function simulates data from a mixture of multivariate
Poisson-log normal factor analyzers family (PMPLNFA). In the
PMPLNFA framework restrictions are introduced to the model
parameters with the aim of obtaining parsimonious models, which
are sufficiently flexible for clustering purposes. Since the
largest contribution of free parameters is through the covariance
matrices, it is the focus for introduction of parsimony.
}
\examples{

# Example 1: Generate 10 datasets from CCC model
# Here, Lambda (loading matrix) and Psi (error variance and
# isotropic) are all constrained and hence CCC

set.seed(100)
numDatasets <- 10 # total number of datasets to be generated
pfactors <- 3 # number of true latent factors
dimensionality <- 10 # dimensionality of observed data
trueClusters <- 2 # number of groups/clusters
mixingProportions <- c(0.32, 0.68) # mixing proportions for 2 clusters
nObservations <- 1000 # sample size or number of observations

# set parameter values
mu <- list(c(6, 3, 3, 6, 3, 6, 3, 3, 6 ,3),
           c(5, 3, 5, 3, 5, 5, 3, 5, 3, 5))

Lambda <- list(matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality),
               matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality))

Psi <- list(diag(dimensionality) * runif(1),
            diag(dimensionality) * runif(1))

# generate datasets
simDataCCC <- mplnFADataGenerator(numDatasets = numDatasets,
                                  nObservations = nObservations,
                                  dimensionality = dimensionality,
                                  mixingProportions = mixingProportions,
                                  trueClusters = trueClusters,
                                  pfactors = pfactors,
                                  modelName = "CCC",
                                  mu = mu,
                                  Lambda = Lambda,
                                  Psi = Psi)

# length of results
length(simDataCCC)

# names of results
names(simDataCCC)

# access dataset 1
simDataCCC$`dataset=1`$dataset

# access input used to generate dataset 1
simDataCCC$`dataset=1`$input

# to generate Sigma values if need for dataset 1
Sigma <- list()
for (gvalue in 1:simDataCCC$`dataset=1`$input$trueClusters) {
 Lambda <- simDataCCC$`dataset=1`$input$Lambda[[gvalue]]
 Psi <- simDataCCC$`dataset=1`$input$Psi[[gvalue]]
 Sigma[[gvalue]] <- Lambda \%*\% t(Lambda) + Psi
}

Sigma[[1]] # Sigma for C1
Sigma[[2]] # Sigma for C2

# access dataset 2
simDataCCC$`dataset=2`$dataset


# Example 2
# Here, Lambda (loading matrix) is unconstrained and Psi
(error variance and isotropic) are all constrained and
hence UCC model is used

set.seed(100)
numDatasets <- 10 # total number of datasets to be generated
pfactors <- 2 # number of true latent factors
dimensionality <- 8 # dimensionality of observed data
trueClusters <- 4 # number of groups/clusters
mixingProportions <- c(0.11, 0.43, 0.24, 0.22) # mixing proportions for 4 clusters
nObservations <- 1000 # sample size or number of observations

# set parameter values
mu <- list(c(6, 3, 3, 6, 3, 6, 3, 3),
           c(5, 3, 5, 3, 5, 3, 3, 5),
           c(4, 2, 6, 4, 2, 6, 4, 4),
           c(1, 3, 5, 1, 3, 5, 3, 5))

Lambda <- list(matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality),
               matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality),
               matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality),
               matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality))

Psi <- list(diag(dimensionality) * runif(1),
            diag(dimensionality) * runif(1),
            diag(dimensionality) * runif(1),
            diag(dimensionality) * runif(1))

# generate datasets
simDataUCC <- mplnFADataGenerator(numDatasets = numDatasets,
                                  nObservations = nObservations,
                                  dimensionality = dimensionality,
                                  mixingProportions = mixingProportions,
                                  trueClusters = trueClusters,
                                  pfactors = pfactors,
                                  modelName = "UCC",
                                  mu = mu,
                                  Lambda = Lambda,
                                  Psi = Psi)

# access dataset 1
simDataUCC$`dataset=1`$dataset

# access input used to generate dataset 1
simDataUCC$`dataset=1`$input


# Example 3
# Here, Lambda (loading matrix) is unconstrained and Psi
(error variance and isotropic) are all unconstrained and
hence UUU model is used

set.seed(100)
numDatasets <- 10 # total number of datasets to be generated
pfactors <- 4 # number of true latent factors
dimensionality <- 10 # dimensionality of observed data
trueClusters <- 3 # number of groups/clusters
mixingProportions <- c(0.23, 0.44, 0.33) # mixing proportions for 4 clusters
nObservations <- 1000 # sample size or number of observations

# set parameter values
mu <- list(c(4, 6, 4, 2, 2, 4, 6, 4, 6, 2),
           c(5, 5, 3, 3, 7, 5, 3, 3, 7, 7),
           c(2, 4, 4, 7, 2, 4, 7, 2, 7, 4))

Lambda <- list(matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality),
               matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality),
               matrix(runif(pfactors * dimensionality, -1, 1), nrow = dimensionality))

Psi <- list(diag(dimensionality) * runif(dimensionality),
            diag(dimensionality) * runif(dimensionality),
            diag(dimensionality) * runif(dimensionality))

# generate datasets
simDataUUU <- mplnFADataGenerator(numDatasets = numDatasets,
                                  nObservations = nObservations,
                                  dimensionality = dimensionality,
                                  mixingProportions = mixingProportions,
                                  trueClusters = trueClusters,
                                  pfactors = pfactors,
                                  modelName = "UUU",
                                  mu = mu,
                                  Lambda = Lambda,
                                  Psi = Psi)

# access dataset 1
simDataUUU$`dataset=1`$dataset

# access input used to generate dataset 1
simDataUUU$`dataset=1`$input

}
\references{
Aitchison, J. and C. H. Ho (1989). The multivariate Poisson-log normal distribution.
\emph{Biometrika} 76.

Silva, A. et al. (2019). A multivariate Poisson-log normal mixture model
for clustering transcriptome sequencing data. \emph{BMC Bioinformatics} 20.
\href{https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-2916-0}{Link}
}
